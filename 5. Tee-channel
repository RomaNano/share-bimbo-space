Паттерн Tee-channel
Tee-канал (от англ. "tee" как в UNIX-команде tee) - это паттерн в Go, который позволяет "разветвить" один канал на несколько потребителей, чтобы одно сообщение отправлялось в несколько каналов.

Основная идея
Когда у вас есть один источник данных (канал) и несколько потребителей, которые должны получать одни и те же данные, вы можете использовать tee-паттерн для дублирования данных в несколько каналов.

Пример реализации
func tee(input <-chan int, outputs ...chan<- int) {
    for v := range input {
        for _, output := range outputs {
            output <- v
        }
    }
    
    // Закрываем все выходные каналы после завершения
    for _, output := range outputs {
        close(output)
    }
}

func main() {
    in := make(chan int)
    out1 := make(chan int)
    out2 := make(chan int)
    
    // Запускаем tee в отдельной горутине
    go tee(in, out1, out2)
    
    // Запускаем потребителей
    go func() {
        for v := range out1 {
            fmt.Println("out1:", v)
        }
    }()
    
    go func() {
        for v := range out2 {
            fmt.Println("out2:", v)
        }
    }()
    
    // Отправляем данные в входной канал
    for i := 0; i < 5; i++ {
        in <- i
    }
    
    close(in)
    time.Sleep(time.Second) // Даем время для обработки
}

                  
Как это работает
Функция tee принимает один входной канал и несколько выходных.
Каждое  значения из входного канала отправляется во все выходные каналы.
После закрытия входного канала закрываются все выходные каналы.
Особенности
Все потребители получают одни и те же данные.
Если один из потребителей медленный, это может замедлить всех (так как отправка в каналы происходит последовательно).
Для решения проблемы с медленными потребителями можно использовать буферизованные каналы или дополнительное разветвление.
Альтернативная реализация с использованием горутин
func tee(input <-chan int, outputs ...chan<- int) {
    for v := range input {
        for _, output := range outputs {
            go func(out chan<- int, val int) {
                out <- val
            }(output, v)
        }
    }
    // ... закрытие каналов
}

                  
Эта версия отправляет данные в выходные каналы параллельно, но может нарушить порядок сообщений.

Tee-паттерн полезен в ситуациях, когда вам нужно разослать одни и те же данные нескольким обработчикам или когда вы хотите реализовать что-то подобное fan-out шаблону, но с одинаковыми данными для всех потребителей.
