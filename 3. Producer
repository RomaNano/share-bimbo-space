Паттерн "Генератор"
Паттерн "Генератор" (или "Producer") позволяет генерировать значения в отдельной горутине и передавать их через канал. Это особенно полезно для:

Ленивой генерации данных.
Параллельной обработки.
Работы с бесконечными последовательностями.
Простейший пример: генератор чисел
package main

import "fmt"

// Генератор чисел от start до end
func numberGenerator(start, end int) <-chan int {
    out := make(chan int) // Создаем канал
    
    go func() {
        for i := start; i <= end; i++ {
            out <- i // Посылаем числа в канал
        }
        close(out) // Важно: закрываем канал после завершения
    }()
    
    return out // Возвращаем канал для чтения
}

func main() {
    // Получаем канал с числами от 1 до 5
    numbers := numberGenerator(1, 5)
    
    // Читаем значения из канала
    for num := range numbers {
        fmt.Println(num)
    }
}

                  
Вывод:

1
2
3
4
5

                  
Создание канала
out := make(chan int) — создается небуферизированный канал.

Запуск горутины
Генерация чисел происходит в фоновой горутине (go func() {...}).

Отправка значений
Каждое число последовательно отправляется в канал: out <- i.

Закрытие канала
close(out) — сигнализирует, что больше данных не будет.

Чтение из канала
Цикл for num := range numbers читает значения до закрытия канала.

Улучшенный пример: бесконечный генератор
package main

import (
	"context"
	"fmt"
	"time"
)

func infiniteGenerator(ctx context.Context) <-chan int {
	out := make(chan int)
	go func() {
		defer close(out) // Гарантируем закрытие канала
		i := 1
		for {
			select {
			case <-ctx.Done():
				return // Выход при отмене контекста
			default:
				out <- i
				i++
				time.Sleep(700 * time.Millisecond)
			}
		}
	}()
	return out
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	for num := range infiniteGenerator(ctx) {
		fmt.Println(num)
	}
	// Цикл завершится, когда генератор закроет канал
}

                  
Функция infiniteGenerator принимает context.Context и запускает горутину, которая генерирует числа с задержкой.
Внутри горутины в бесконечном цикле есть select на ctx.Done() — при отмене контекста горутина завершает работу и закрывает канал.
В функции main создаётся контекст с таймаутом 3 секунды.
Цикл for читает из канала, пока он открыт. После срабатывания таймаута горутина закрывает канал — цикл завершается.
Данный код: 

Явно передаёт контекст в генератор.
Закрывает канал при отмене.
Гарантирует корректное завершение цикла for range.
Паттерны использования
1. Фильтрация значений

func filter(in <-chan int, predicate func(int) bool) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            if predicate(n) {
                out <- n
            }
        }
        close(out)
    }()
    return out
}

// Только четные числа
evens := filter(numberGenerator(1, 10), func(n int) bool {
    return n%2 == 0
})

                  
2. Пайплайн обработки

// Генератор -> Квадратор -> Принтер
nums := numberGenerator(1, 5)
squares := squareTransformer(nums) // Отдельная функция-трансформер
printAll(squares)

                  
Важные нюансы
Всегда закрывайте каналы, иначе range будет ждать вечно.
Небуферизированные каналы синхронизируют отправку/получение.
Для отмены используйте context.Context.
Преимущества подхода
Ленивые вычисления: Данные генерируются только когда запрашиваются.
Параллелизм: Генерация и обработка могут работать в разных горутинах.
Чистый код: Разделение ответственности между компонентами.
