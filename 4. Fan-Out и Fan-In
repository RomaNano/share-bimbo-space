Паттерны Fan-Out и Fan-In
Fan-Out и Fan-In - это важные шаблоны работы с параллелизмом в Go, которые позволяют эффективно распределять и собирать данные между горутинами, они позволяют эффективно распараллеливать задачи и собирать результаты обратно в один поток. Эти шаблоны часто используются для построения масштабируемых и производительных систем на базе горутин и каналов.

Fan-Out (Разветвление)
Fan-Out (Демультиплексор) означает распределение работы между несколькими горутинами-воркерами из одного канала. Шаблон Fan-Out (Демультиплексор) равномерно распределяет сообщения из одного входного канала между несколькими выходными каналами. Это очень полезный шаблон для распараллеливания вычислительных ресурсов и ресурсов ввода/вывода. 
Например, представьте, что у вас есть источник данных, входной поток или брокер сообщений, который предоставляет входные данные для некоторой ресурсоемкой работы. Вместо того чтобы связывать процессы ввода и вычислений в один последовательный процесс, можно просто распараллелить рабочую нагрузку, распределив ее между несколькими вычислительными процессами.

func fanOut(input <-chan int, output chan<- int, workerCount int) {
    var wg sync.WaitGroup
    wg.Add(workerCount)
    
    for i := 0; i < workerCount; i++ {
        go func() {
            defer wg.Done()
            for num := range input {
                // Имитация обработки
                result := num * 2
                output <- result
            }
        }()
    }
    
    // Закрываем output после завершения всех воркеров
    go func() {
        wg.Wait()
        close(output)
    }()
}

                  
Поскольку параллельная обработка не является детерминированной, некоторые сообщения будут обрабатываться быстрее, чем другие, в результате чего сообщения будут обрабатываться в непредсказуемом порядке. Схема разветвления имеет смысл, только если мы не заботимся о порядке входящих сообщений.

Fan-In (Слияние)
Fan-In (Мультиплексор) означает сбор результатов работы нескольких горутин в один канал. В службах, имеющих несколько рабочих процессов, генерирующих результаты, бывает полезно объединить эти результаты в один общий поток. В таких случаях используется шаблон Fan-In (Мультиплексор), позволяющий читать данные из нескольких входных каналов и передавать их в один целевой канал.

func fanIn(inputs ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    output := make(chan int)
    
    // Функция для копирования значений из одного канала в output
    copy := func(c <-chan int) {
        defer wg.Done()
        for n := range c {
            output <- n
        }
    }
    
    wg.Add(len(inputs))
    for _, c := range inputs {
        go copy(c)
    }
    
    // Закрываем output после завершения всех горутин
    go func() {
        wg.Wait()
        close(output)
    }()
    
    return output
}

                  
Наличие нескольких горутин, работающих в одном общем канале, создаёт проблему. Когда у нас есть горутина с каналом ввода-вывода «один к одному», стратегия закрытия канала проста: закрыть выход после закрытия входного канала. Когда у нас есть сценарий с объединением «многие к одному», мы должны принять решение о том, когда закрывать общий канал. Если мы продолжим использовать тот же подход, закрывая канал, когда горутина замечает, что канал, из которого она потребляет данные, закрыт, мы можем закрыть канал слишком рано. Другая горутина может всё ещё выводить сообщения.
Решение состоит в том, чтобы закрывать общий канал только тогда, когда все горутины заметили, что каналы, из которых
они потребляют данные, закрыты. Для этого можно использовать группу ожидания. Каждая горутина в группе «fan-in» отмечает группу ожидания как выполненную после отправки своего последнего сообщения. У нас есть отдельная горутина, которая вызывает wait() для этой группы ожидания, что приостанавливает её выполнение до завершения всех горутин «fan-in». После возобновления работы эта горутина закроет выходной канал.

Пример:

ch := make(chan int)
var wg sync.WaitGroup

// Запускаем несколько горутин-отправителей
for i := 0; i < 5; i++ {
    wg.Add(1)
    go func() {
        defer wg.Done()
        for j := 0; j < 10; j++ {
            ch <- j
        }
    }()
}

// Закрываем канал, когда все горутины завершатся
go func() {
    wg.Wait()
    close(ch)
}()

// Читаем из канала
for val := range ch {
    fmt.Println(val)
}

                  
Никогда не закрывайте общий канал из нескольких горутин, если есть вероятность, что кто-то ещё будет писать.
Организуйте координацию через WaitGroup или другой способ.
Закрывайте канал единым ответственным потоком после того, как все отправители завершили работу.
Пример использования вместе
func main() {
    // Создаем входной канал
    input := make(chan int)
    
    // Горутина для генерации данных
    go func() {
        for i := 0; i < 10; i++ {
            input <- i
        }
        close(input)
    }()
    
    // Промежуточный канал для Fan-Out
    processed := make(chan int)
    
    // Запускаем Fan-Out с 3 воркерами
    fanOut(input, processed, 3)
    
    // Создаем несколько каналов для Fan-In
    split1 := make(chan int)
    split2 := make(chan int)
    
    // Разделяем processed канал на два
    go func() {
        for n := range processed {
            split1 <- n
            split2 <- n
        }
        close(split1)
        close(split2)
    }()
    
    // Объединяем каналы обратно с Fan-In
    merged := fanIn(split1, split2)
    
    // Выводим результаты
    for result := range merged {
        fmt.Println(result)
    }
}

                  
Таким образом, мы можем распределить работу между набором горутин.

Преимущества шаблонов
Распределение нагрузки - Fan-Out позволяет распределить работу между несколькими воркерами.
Масштабируемость - можно легко увеличивать количество воркеров.
Чистота архитектуры - разделение ответственности между компонентами.
Гибкость - можно комбинировать эти шаблоны с другими паттернами.
Эти шаблоны особенно полезны для обработки больших объемов данных, задач, требующих параллельной обработки, и построения конвейеров обработки данных.

В базовой реализации паттерна fan-in/fan-out  результаты, поступающие от воркеров, собираются в канал без сохранения порядка — данные приходят по мере завершения задач, что удобно для максимальной производительности, но не гарантирует последовательность результатов относительно исходного порядка задач. Если порядок важен (например, нужно, чтобы результат i-й задачи всегда был на i-м месте в итоговой выборке), стандартная реализация не подходит. 

Для сохранения порядка результатов при использовании fan-in/fan-out  используйте, например, передачу индекса задачи в воркер, а затем собирайте результаты в слайс или через буфер с сортировкой по индексу. Это стандартная практика, позволяющая сохранить преимущества параллелизма и корректный порядок данных. 
