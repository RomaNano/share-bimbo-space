Паттерн Bridge-Channel
Паттерн Bridge-Channel ("мост-канал") используется для соединения нескольких каналов в один, эффективно создавая мост между производителями и потребителями. Это особенно полезно, когда у вас есть несколько источников данных, которые нужно обрабатывать единообразно.

Основная идея
Принимает канал каналов (chan chan T).
"Разворачивает" их в один плоский канал (chan T).
Позволяет обрабатывать значения из всех исходных каналов как из одного потока.
Пример реализации
func bridge(done <-chan struct{}, chanStream <-chan <-chan interface{}) <-chan interface{} {
    valStream := make(chan interface{})
    
    go func() {
        defer close(valStream)
        
        for {
            var stream <-chan interface{}
            
            // Выбираем следующий канал из chanStream
            select {
            case maybeStream, ok := <-chanStream:
                if !ok {
                    return
                }
                stream = maybeStream
            case <-done:
                return
            }
            
            // Читаем значения из выбранного канала
            for val := range stream {
                select {
                case valStream <- val:
                case <-done:
                }
            }
        }
    }()
    
    return valStream
}

                  
Как это работает
Функция bridge принимает:

Канал для отмены (done)

Канал каналов (chanStream)

Внутри создается новый канал (valStream), который будет объединять все значения.

В горутине:

Берётся очередной канал из chanStream.

Все значения из этого канала перенаправляются в valStream.

Процесс повторяется для следующего канала.

Пример использования
func main() {
    done := make(chan struct{})
    defer close(done)
    
    // Создаем канал каналов
    chanStream := make(chan (<-chan interface{}))
    
    go func() {
        defer close(chanStream)
        
        // Создаем несколько каналов и отправляем их в chanStream
        for i := 0; i < 3; i++ {
            stream := make(chan interface{}, 2)
            stream <- i
            stream <- i * 10
            close(stream)
            chanStream <- stream
        }
    }()
    
    // Читаем объединенный поток
    for v := range bridge(done, chanStream) {
        fmt.Printf("%v ", v)
    }
    // Output: 0 0 1 10 2 20
}

                  
Преимущества паттерна
Декомпозиция: Позволяет разделить генерацию данных и их потребление.
Гибкость: Можно динамически добавлять новые источники данных.
Управление потоком: Централизованное управление несколькими каналами.
Варианты использования
Агрегация данных из нескольких источников.
Обработка данных из динамически создаваемых каналов.
Реализация сложных pipeline'ов обработки данных.
Альтернативная реализация с помощью generics (Go 1.18+)
func bridge[T any](done <-chan struct{}, chanStream <-chan <-chan T) <-chan T {
    valStream := make(chan T)
    
    go func() {
        defer close(valStream)
        
        for {
            var stream <-chan T
            select {
            case maybeStream, ok := <-chanStream:
                if !ok { return }
                stream = maybeStream
            case <-done: return
            }
            
            for val := range stream {
                select {
                case valStream <- val:
                case <-done: return
                }
            }
        }
    }()
    
    return valStream
}

                  
Bridge-паттерн особенно полезен в сценариях, где количество или состав источников данных может меняться во время выполнения программы, но потребитель хочет работать с единым потоком данных.

Сравнение с паттерном Fan-In
Характеристика	Fan-In	Bridge-Channel
Входные данные	Несколько каналов	Канал каналов
Динамичность	Фиксированные	Могут добавляться новые
Порядок обработки	Параллельный	Последовательный
Типичное использование	Агрегация результатов	Потоковая обработка динамических источников
Сложность	Проще	Сложнее
Когда что использовать
Используйте Fan-In/Out когда:

У вас фиксированное количество источников/обработчиков.
Нужно распараллелить обработку.
Работаете с однородными каналами.
Используйте Bridge когда:

Источники данных появляются динамически.
Работаете с последовательностью временных каналов.
Нужно обрабатывать каналы, которые сами приходят через канал.
 

О канале каналов
Канал каналов (chan chan T) — это специальный тип канала в Go, который передаёт другие каналы как значения. Это мощный паттерн для построения сложных коммуникационных структур между горутинами.

Основные особенности:

Тип: chan <-chan T (только для чтения) или chan chan<- T (только для записи)

Использование:

Для динамической маршрутизации данных.

Создания гибких pipeline'ов.

Реализации паттернов bridge и fan-in/fan-out.

Пример:

func main() {
    // Канал, передающий каналы int
    chanOfChans := make(chan chan int)
    
    go func() {
        // Создаём новый канал и отправляем его
        ch := make(chan int, 2)
        ch <- 1
        ch <- 2
        chanOfChans <- ch
        close(chanOfChans)
    }()
    
    // Получаем канал из канала
    receivedCh := <-chanOfChans
    close(receivedCh)
    
    // Читаем из полученного канала
    for v := range receivedCh {
        fmt.Println(v) // Выведет 1, затем 2
    }
}

                  
Где применяется:
Динамические worker pools - управление набором воркеров.
Обработка временных потоков данных - когда источники появляются/исчезают.
Сложные системы маршрутизации сообщений.
Канал каналов позволяет создавать более гибкие и динамические коммуникационные паттерны между горутинами по сравнению с фиксированными структурами каналов.
