Конвейеры
Конвейер в программировании - это набор функций, которые работают последовательно и передают данные между собой для обработки. Конвейеры могут использоваться для асинхронной обработки данных, в том числе для реализации параллельной обработки.

Конвейер (pipeline) в Go — это паттерн проектирования, где данные передаются последовательно через несколько горутин, каждая из которых выполняет определённую операцию обработки.

Основные компоненты конвейера
Горутины — независимые потоки выполнения.
Каналы — механизмы передачи данных между горутинами.
Этапы обработки — отдельные блоки обработки данных.
Рассмотрим пример конвейера, который будет обрабатывать строку текста. Каждая горутина будет выполнять различные операции над строкой, передавая ее дальше по конвейеру.

Сначала мы создаем каналы, которые будут использоваться для передачи данных между горутинами:

var wg sync.WaitGroup

input := make(chan string)
output1 := make(chan string)
output2 := make(chan string)

                  
Первая горутина будет читать данные с канала input, преобразовывать каждое слово в верхний регистр и отправлять обратно на output1:

wg.Add(1)
go func() {
    defer wg.Done()
    for s := range input {
        words := strings.Split(s, " ")
        for i, w := range words {
            words[i] = strings.ToUpper(w)
        }
        output1 <- strings.Join(words, " ")
    }
    close(output1)
}()

                  
Вторая горутина будет читать данные с канала output1, заменять гласные буквы на звездочки и отправлять результат на output2:

wg.Add(1)
go func() {
    defer wg.Done()
    for s := range output1 {
        vowels := "AEIOUaeiou"
        for _, v := range vowels {
            s = strings.Replace(s, string(v), "*", -1)
        }
        output2 <- s
    }
    close(output2)
}()

                  
Наконец, мы можем использовать последнюю горутину, чтобы прочитать итоговые данные с канала output2:

wg.Add(1)
go func() {
    defer wg.Done()
    for s := range output2 {
        fmt.Println(s)
    }
}()

                  
Теперь мы можем отправлять данные в конвейер через канал input, и они будут обрабатываться каждой из трех горутин:

input <- "Hello world"
input <- "Go is awesome"
input <- "Concurrency is the future"
close(input)

wg.Wait()

                  
В итоге мы получим следующий вывод:

H*LL* W*RLD
GO *S *W*SM*
C*NCCR*NCY *S TH* F*T*R*

                  
Это простой пример, но его легко изменить, чтобы обрабатывать более сложные данные и выполнять более сложные задачи в конвейерном стиле.

Пример: Конвейер из трёх стадий
package main

import (
    "fmt"
)

// Первая стадия: генерирует числа от 1 до n и отправляет в канал
func gen(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

// Вторая стадия: принимает числа, возводит в квадрат и отправляет дальше
func sq(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

// Третья стадия: принимает числа и выводит их
func print(in <-chan int) {
    for n := range in {
        fmt.Println(n)
    }
}

func main() {
    // Создаем конвейер: ген -> sq -> print
    c := gen(2, 3, 4, 5)
    c2 := sq(c)
    print(c2)
}

                  
Функция gen запускает горутину, которая отправляет последовательность чисел в канал и закрывает его.
Функция sq запускает горутину, которая читает числа из входного канала, возводит их в квадрат и отправляет в выходной канал, затем закрывает его.
Функция print читает из канала и выводит значения.
В main эти функции связаны последовательно, образуя конвейер обработки данных.
Особенности каналов в этом примере

Каналы синхронизируют работу горутин: sq не начнёт обработку следующего числа, пока print не прочитает текущее.
Закрытие каналов сигнализирует о завершении передачи данных.
Используются однонаправленные каналы (<-chan int для чтения, chan<- int для записи) для повышения безопасности типов.
Этот пример демонстрирует базовый паттерн конвейера в Go с использованием каналов и горутин, позволяющий строить эффективные и безопасные конвейерные обработки данных.

Преимущества конвейера
Параллелизм — каждая стадия может выполняться независимо.
Масштабируемость — легко добавлять новые стадии обработки.
Изоляция — каждая стадия независима от других.
Эффективность — оптимальное использование ресурсов.
Типичные ошибки при работе с конвейерами
Deadlock — блокировка из-за неправильного закрытия каналов.
Гонка данных — несогласованный доступ к общим ресурсам.
Утечка горутин — незакрытые горутины.
Переполнение буфера — слишком большой объём данных в каналах.
