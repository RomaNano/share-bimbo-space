Пример параллельной сортировки массива с использованием select
package main

import (
    "fmt"
    "sort"
)

func main() {
    data := []int{34, 7, 23, 32, 5, 62, 31, 25, 12, 8} // Входной массив с неотсортированными числами
    sorted := parallelSort(data)
    fmt.Println("Отсортированный массив:", sorted)
}

func parallelSort(arr []int) []int {
    // Делим массив на 2 части
    part1, part2 := arr[:len(arr)/2], arr[len(arr)/2:]

    // Создаём два небуферизированных канала для получения результатов
    ch1, ch2 := make(chan []int), make(chan []int)

    // Запускаем сортировку в горутинах
    go func() { sort.Ints(part1); ch1 <- part1 }()
    go func() { sort.Ints(part2); ch2 <- part2 }()

    // Ждём результаты через select
    var sorted1, sorted2 []int
    for i := 0; i < 2; i++ {
        select {
        case sorted1 = <-ch1:
        case sorted2 = <-ch2:
        }
    }

    // Объединяем результаты
    return merge(sorted1, sorted2)
}

func merge(a, b []int) []int {
    result := make([]int, 0, len(a)+len(b))
    i, j := 0, 0

    for i < len(a) && j < len(b) {
        if a[i] < b[j] {
            result = append(result, a[i])
            i++
        } else {
            result = append(result, b[j])
            j++
        }
    }
    return append(append(result, a[i:]...), b[j:]...)
}

                  
 Пояснения

1. Функция main:

Определяем входной массив data с неотсортированными числами.
Вызываем функцию parallelSort для  сортировки data
Выводим результат.
2. Функция parallelSort - основная логика:

Делим массив на две примерно равные части, part1 - первая половина, part2 - вторая половина.
Создаём два небуферизированных канала для получения результатов,ch1 - для первой части, ch2 - для второй части.
Запускаем две горутины,  первая сортирует part1 и отправляет результат в ch1, вторая сортирует part2 и отправляет результат в ch2 , обе горутины работают параллельно.
Цикл выполняется 2 раза (по числу ожидаемых результатов), select ожидает данные из любого канала (ch1 или ch2), как только данные поступают из одного канала, они сохраняются в соответствующую переменную, на второй итерации получаем данные из второго канала.
Вызываем функцию merge для объединения двух отсортированных половин, возвращаем итоговый отсортированный массив.
3. Функция merge - слияние двух отсортированных массивов:

Создаём результирующий массив с ёмкостью, равной сумме длин входных массивов.
Используем два указателя (i для a, j для b).
Сравниваем элементы на текущих позициях, если элемент из a меньше - добавляем его в результат и увеличиваем i, иначе добавляем элемент из b и увеличиваем j.
После окончания одного из массивов добавляем оставшиеся элементы из другого.
Особенности работы select в этом коде
    1. Неблокирующее ожидание:

select позволяет ждать данные из нескольких каналов одновременно.
Неважно, в каком порядке придут результаты - код корректно их обработает.
    2. Гарантия получения всех результатов:

Цикл for i := 0; i < 2; i++ гарантирует, что мы получим оба результата.
Даже если одна горутина выполнится быстрее другой.
    3. Отсутствие deadlock:

Так как мы точно знаем, что будет 2 результата, и ждём ровно 2 раза.
Все горутины гарантированно отправят свои результаты.
Этот пример демонстрирует классический шаблон "разделяй и властвуй" с использованием горутин и каналов в Go.
